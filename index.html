<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaurav Dixit's - Sorting Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }

        body {
            background-color: #0a0a0a;
            color: #00ff00;
            overflow-x: hidden;
            min-height: 100vh;
            position: relative;
        }

        /* Matrix background effect */
        .matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.1;
        }

        .matrix-char {
            position: absolute;
            color: #00ff00;
            font-size: 14px;
            animation: matrix-fall linear infinite;
        }

        @keyframes matrix-fall {
            0% {
                transform: translateY(-100%);
                opacity: 0;
            }
            5% {
                opacity: 1;
            }
            95% {
                opacity: 1;
            }
            100% {
                transform: translateY(1000%);
                opacity: 0;
            }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #00ff00;
            border-radius: 5px;
            background-color: rgba(0, 20, 0, 0.3);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 0, 0.1), transparent);
            animation: scanning 3s linear infinite;
        }

        @keyframes scanning {
            0% {
                left: -100%;
            }
            100% {
                left: 100%;
            }
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ff00;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #00cc00;
        }

        .terminal {
            background-color: rgba(0, 10, 0, 0.7);
            border: 1px solid #00ff00;
            border-radius: 5px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.2);
        }

        .terminal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #003300;
        }

        .terminal-title {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .terminal-controls {
            display: flex;
            gap: 10px;
        }

        .terminal-btn {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .close {
            background-color: #ff5f56;
        }

        .minimize {
            background-color: #ffbd2e;
        }

        .maximize {
            background-color: #27ca3f;
        }

        .command-line {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .prompt {
            margin-right: 10px;
            color: #00ff00;
        }

        .command {
            background: transparent;
            border: none;
            color: #00ff00;
            font-size: 1rem;
            width: 100%;
            outline: none;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-weight: bold;
            color: #00cc00;
        }

        select, button, input {
            padding: 10px 15px;
            border: 1px solid #003300;
            border-radius: 3px;
            background-color: #001100;
            color: #00ff00;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            outline: none;
        }

        select {
            background: #001100 url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6' viewBox='0 0 10 6'%3E%3Cpath fill='%2300ff00' d='M5 6L0 0h10L5 6z'/%3E%3C/svg%3E") no-repeat right 10px center;
            background-size: 10px;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        button {
            background: linear-gradient(to bottom, #002200, #001100);
            border: 1px solid #00aa00;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 0, 0.2), transparent);
            transition: left 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        button:active {
            transform: translateY(1px);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: none;
        }

        button:disabled:hover::before {
            left: -100%;
        }

        input[type="range"] {
            -webkit-appearance: none;
            background: #001100;
            height: 5px;
            border-radius: 5px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #00ff00;
            cursor: pointer;
            box-shadow: 0 0 5px #00ff00;
        }

        .visualization {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            height: 300px;
            background-color: #000800;
            border: 1px solid #003300;
            border-radius: 3px;
            padding: 20px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }

        .bar {
            margin: 0 2px;
            background: linear-gradient(to top, #003300, #00aa00);
            border-radius: 2px 2px 0 0;
            transition: height 0.3s ease, background-color 0.3s ease;
            position: relative;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
        }

        .bar.comparing {
            background: linear-gradient(to top, #553300, #ffaa00);
            box-shadow: 0 0 10px #ffaa00;
        }

        .bar.swapping {
            background: linear-gradient(to top, #550000, #ff0000);
            box-shadow: 0 0 10px #ff0000;
        }

        .bar.sorted {
            background: linear-gradient(to top, #005500, #00ff00);
            box-shadow: 0 0 10px #00ff00;
        }

        .bar.pivot {
            background: linear-gradient(to top, #330055, #aa00ff);
            box-shadow: 0 0 10px #aa00ff;
        }

        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .info-card {
            background-color: rgba(0, 20, 0, 0.3);
            border: 1px solid #003300;
            border-radius: 3px;
            padding: 20px;
        }

        .info-card h3 {
            margin-bottom: 15px;
            color: #00cc00;
            font-size: 1.3rem;
            border-bottom: 1px solid #003300;
            padding-bottom: 5px;
        }

        .algorithm-info {
            line-height: 1.6;
            color: #00aa00;
        }

        .complexity {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }

        .complexity-item {
            text-align: center;
        }

        .complexity-value {
            font-size: 1.2rem;
            font-weight: 700;
            margin-top: 5px;
        }

        .best { color: #00ff00; }
        .average { color: #ffff00; }
        .worst { color: #ff5555; }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 2px;
        }

        .normal { background: linear-gradient(to top, #003300, #00aa00); }
        .comparing { background: linear-gradient(to top, #553300, #ffaa00); }
        .swapping { background: linear-gradient(to top, #550000, #ff0000); }
        .sorted { background: linear-gradient(to top, #005500, #00ff00); }
        .pivot { background: linear-gradient(to top, #330055, #aa00ff); }

        .status {
            text-align: center;
            font-size: 1.2rem;
            margin-top: 20px;
            font-weight: 600;
            height: 30px;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
        }

        .blinking-cursor {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .visualization {
                height: 250px;
            }
            
            h1 {
                font-size: 2rem;
            }
        }

        .pulse {
            animation: pulse 0.5s ease-in-out;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .glitch {
            position: relative;
        }

        .glitch::before, .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .glitch::before {
            left: 2px;
            text-shadow: -1px 0 #ff00ff;
            clip: rect(44px, 450px, 56px, 0);
            animation: glitch-anim 5s infinite linear alternate-reverse;
        }

        .glitch::after {
            left: -2px;
            text-shadow: -1px 0 #00ffff;
            clip: rect(44px, 450px, 56px, 0);
            animation: glitch-anim2 5s infinite linear alternate-reverse;
        }

        @keyframes glitch-anim {
            0% { clip: rect(42px, 9999px, 44px, 0); }
            5% { clip: rect(12px, 9999px, 59px, 0); }
            10% { clip: rect(48px, 9999px, 29px, 0); }
            15% { clip: rect(42px, 9999px, 73px, 0); }
            20% { clip: rect(63px, 9999px, 27px, 0); }
            25% { clip: rect(34px, 9999px, 55px, 0); }
            30% { clip: rect(86px, 9999px, 73px, 0); }
            35% { clip: rect(20px, 9999px, 20px, 0); }
            40% { clip: rect(26px, 9999px, 60px, 0); }
            45% { clip: rect(25px, 9999px, 66px, 0); }
            50% { clip: rect(57px, 9999px, 98px, 0); }
            55% { clip: rect(5px, 9999px, 46px, 0); }
            60% { clip: rect(82px, 9999px, 31px, 0); }
            65% { clip: rect(54px, 9999px, 27px, 0); }
            70% { clip: rect(28px, 9999px, 99px, 0); }
            75% { clip: rect(45px, 9999px, 69px, 0); }
            80% { clip: rect(23px, 9999px, 85px, 0); }
            85% { clip: rect(54px, 9999px, 84px, 0); }
            90% { clip: rect(45px, 9999px, 47px, 0); }
            95% { clip: rect(37px, 9999px, 20px, 0); }
            100% { clip: rect(4px, 9999px, 91px, 0); }
        }

        @keyframes glitch-anim2 {
            0% { clip: rect(65px, 9999px, 100px, 0); }
            5% { clip: rect(52px, 9999px, 74px, 0); }
            10% { clip: rect(79px, 9999px, 85px, 0); }
            15% { clip: rect(75px, 9999px, 5px, 0); }
            20% { clip: rect(67px, 9999px, 61px, 0); }
            25% { clip: rect(14px, 9999px, 79px, 0); }
            30% { clip: rect(1px, 9999px, 66px, 0); }
            35% { clip: rect(86px, 9999px, 30px, 0); }
            40% { clip: rect(23px, 9999px, 98px, 0); }
            45% { clip: rect(85px, 9999px, 72px, 0); }
            50% { clip: rect(71px, 9999px, 75px, 0); }
            55% { clip: rect(2px, 9999px, 48px, 0); }
            60% { clip: rect(30px, 9999px, 16px, 0); }
            65% { clip: rect(59px, 9999px, 50px, 0); }
            70% { clip: rect(41px, 9999px, 62px, 0); }
            75% { clip: rect(2px, 9999px, 82px, 0); }
            80% { clip: rect(47px, 9999px, 73px, 0); }
            85% { clip: rect(3px, 9999px, 27px, 0); }
            90% { clip: rect(26px, 9999px, 55px, 0); }
            95% { clip: rect(42px, 9999px, 97px, 0); }
            100% { clip: rect(38px, 9999px, 49px, 0); }
        }
    </style>
</head>
<body>
    <div class="matrix-bg" id="matrixBg"></div>
    
    <div class="container">
        <header>
            <h1 class="glitch" data-text="Gaurav Dixit's">Gaurav Dixit's</h1>
            <p class="subtitle">SORTING ALGORITHM VISUALIZER</p>
        </header>

        <div class="terminal">
            <div class="terminal-header">
                <div class="terminal-title">root@hacker:~# sorting_visualizer</div>
                <div class="terminal-controls">
                    <div class="terminal-btn close"></div>
                    <div class="terminal-btn minimize"></div>
                    <div class="terminal-btn maximize"></div>
                </div>
            </div>
            
            <div class="command-line">
                <span class="prompt">[user@algorithm-visualizer]$</span>
                <input type="text" class="command" id="commandInput" placeholder="Type 'help' for commands...">
                <span class="blinking-cursor">_</span>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="algorithm">ALGORITHM</label>
                    <select id="algorithm">
                        <option value="bubble">BUBBLE SORT</option>
                        <option value="selection">SELECTION SORT</option>
                        <option value="insertion">INSERTION SORT</option>
                        <option value="merge">MERGE SORT</option>
                        <option value="quick">QUICK SORT</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="arraySize">ARRAY SIZE</label>
                    <input type="range" id="arraySize" min="10" max="100" value="40">
                    <span id="arraySizeValue">40</span>
                </div>

                <div class="control-group">
                    <label for="speed">ANIMATION SPEED</label>
                    <input type="range" id="speed" min="1" max="10" value="5">
                    <span id="speedValue">5</span>
                </div>

                <div class="control-group">
                    <label>&nbsp;</label>
                    <button id="generateArray">GENERATE ARRAY</button>
                </div>

                <div class="control-group">
                    <label>&nbsp;</label>
                    <button id="startSorting">EXECUTE SORT</button>
                </div>
            </div>
        </div>

        <div class="visualization" id="visualization"></div>

        <div class="status" id="status">> SYSTEM READY</div>

        <div class="info-panel">
            <div class="info-card">
                <h3>ALGORITHM SPECS</h3>
                <div class="algorithm-info" id="algorithmInfo">
                    > SELECT AN ALGORITHM TO VIEW SPECIFICATIONS
                </div>
            </div>

            <div class="info-card">
                <h3>TIME COMPLEXITY</h3>
                <div class="complexity">
                    <div class="complexity-item">
                        <div>BEST CASE</div>
                        <div class="complexity-value best" id="bestCase">-</div>
                    </div>
                    <div class="complexity-item">
                        <div>AVERAGE CASE</div>
                        <div class="complexity-value average" id="averageCase">-</div>
                    </div>
                    <div class="complexity-item">
                        <div>WORST CASE</div>
                        <div class="complexity-value worst" id="worstCase">-</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color normal"></div>
                <span>NORMAL ELEMENT</span>
            </div>
            <div class="legend-item">
                <div class="legend-color comparing"></div>
                <span>COMPARING</span>
            </div>
            <div class="legend-item">
                <div class="legend-color swapping"></div>
                <span>SWAPPING</span>
            </div>
            <div class="legend-item">
                <div class="legend-color sorted"></div>
                <span>SORTED</span>
            </div>
            <div class="legend-item">
                <div class="legend-color pivot"></div>
                <span>PIVOT (QUICK SORT)</span>
            </div>
        </div>
    </div>

    <script>
        // DOM elements
        const visualization = document.getElementById('visualization');
        const algorithmSelect = document.getElementById('algorithm');
        const arraySizeSlider = document.getElementById('arraySize');
        const arraySizeValue = document.getElementById('arraySizeValue');
        const speedSlider = document.getElementById('speed');
        const speedValue = document.getElementById('speedValue');
        const generateArrayBtn = document.getElementById('generateArray');
        const startSortingBtn = document.getElementById('startSorting');
        const status = document.getElementById('status');
        const algorithmInfo = document.getElementById('algorithmInfo');
        const bestCase = document.getElementById('bestCase');
        const averageCase = document.getElementById('averageCase');
        const worstCase = document.getElementById('worstCase');
        const commandInput = document.getElementById('commandInput');
        const matrixBg = document.getElementById('matrixBg');

        // Matrix background effect
        function createMatrixEffect() {
            const chars = '01アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';
            const fontSize = 14;
            const columns = Math.floor(window.innerWidth / fontSize);
            
            for (let i = 0; i < columns; i++) {
                const char = document.createElement('div');
                char.className = 'matrix-char';
                char.style.left = `${i * fontSize}px`;
                char.style.animationDuration = `${Math.random() * 10 + 10}s`;
                char.style.animationDelay = `${Math.random() * 5}s`;
                char.textContent = chars.charAt(Math.floor(Math.random() * chars.length));
                matrixBg.appendChild(char);
            }
        }

        // Algorithm information
        const algorithmDetails = {
            bubble: {
                name: "BUBBLE SORT",
                info: "> A simple comparison-based algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.",
                best: "O(n)",
                average: "O(n²)",
                worst: "O(n²)"
            },
            selection: {
                name: "SELECTION SORT",
                info: "> Divides the input into sorted and unsorted regions. Repeatedly selects the smallest element from the unsorted region and moves it to the sorted region.",
                best: "O(n²)",
                average: "O(n²)",
                worst: "O(n²)"
            },
            insertion: {
                name: "INSERTION SORT",
                info: "> Builds the final sorted array one item at a time. Efficient for small data sets or nearly sorted data.",
                best: "O(n)",
                average: "O(n²)",
                worst: "O(n²)"
            },
            merge: {
                name: "MERGE SORT",
                info: "> A divide and conquer algorithm that divides the input array into two halves, sorts them, and then merges the sorted halves.",
                best: "O(n log n)",
                average: "O(n log n)",
                worst: "O(n log n)"
            },
            quick: {
                name: "QUICK SORT",
                info: "> Selects a 'pivot' element and partitions the other elements into two sub-arrays according to whether they are less than or greater than the pivot.",
                best: "O(n log n)",
                average: "O(n log n)",
                worst: "O(n²)"
            }
        };

        // Global variables
        let array = [];
        let isSorting = false;
        let animationSpeed = 200;
        let animations = [];

        // Initialize
        function init() {
            createMatrixEffect();
            updateAlgorithmInfo();
            generateNewArray();
            
            // Event listeners
            algorithmSelect.addEventListener('change', updateAlgorithmInfo);
            arraySizeSlider.addEventListener('input', updateArraySize);
            speedSlider.addEventListener('input', updateSpeed);
            generateArrayBtn.addEventListener('click', generateNewArray);
            startSortingBtn.addEventListener('click', startSorting);
            
            // Command line functionality
            commandInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    processCommand(commandInput.value);
                    commandInput.value = '';
                }
            });
        }

        // Process terminal commands
        function processCommand(cmd) {
            cmd = cmd.toLowerCase().trim();
            let response = "";
            
            switch(cmd) {
                case 'help':
                    response = "> Available commands: help, clear, run, stop, reset, list, size [n], speed [1-10]";
                    break;
                case 'clear':
                    response = "> Terminal cleared";
                    setTimeout(() => {
                        status.textContent = "> SYSTEM READY";
                    }, 1000);
                    break;
                case 'run':
                    if (!isSorting) {
                        startSorting();
                        response = "> Executing sort algorithm...";
                    } else {
                        response = "> Sort already in progress";
                    }
                    break;
                case 'stop':
                    if (isSorting) {
                        // In a real implementation, we would stop the sorting
                        response = "> Process termination not implemented in demo";
                    } else {
                        response = "> No active processes";
                    }
                    break;
                case 'reset':
                    generateNewArray();
                    response = "> Array reset to initial state";
                    break;
                case 'list':
                    response = "> Available algorithms: bubble, selection, insertion, merge, quick";
                    break;
                default:
                    if (cmd.startsWith('size ')) {
                        const size = parseInt(cmd.split(' ')[1]);
                        if (size >= 10 && size <= 100) {
                            arraySizeSlider.value = size;
                            updateArraySize();
                            response = `> Array size set to ${size}`;
                        } else {
                            response = "> Invalid size. Must be between 10 and 100";
                        }
                    } else if (cmd.startsWith('speed ')) {
                        const speed = parseInt(cmd.split(' ')[1]);
                        if (speed >= 1 && speed <= 10) {
                            speedSlider.value = speed;
                            updateSpeed();
                            response = `> Animation speed set to ${speed}`;
                        } else {
                            response = "> Invalid speed. Must be between 1 and 10";
                        }
                    } else if (algorithmDetails[cmd]) {
                        algorithmSelect.value = cmd;
                        updateAlgorithmInfo();
                        response = `> Algorithm set to ${algorithmDetails[cmd].name}`;
                    } else {
                        response = `> Command not found: ${cmd}. Type 'help' for available commands.`;
                    }
            }
            
            status.textContent = response;
        }

        // Update algorithm information
        function updateAlgorithmInfo() {
            const algorithm = algorithmSelect.value;
            const details = algorithmDetails[algorithm];
            
            algorithmInfo.textContent = details.info;
            bestCase.textContent = details.best;
            averageCase.textContent = details.average;
            worstCase.textContent = details.worst;
            
            status.textContent = `> Algorithm set to: ${details.name}`;
        }

        // Update array size display
        function updateArraySize() {
            const size = arraySizeSlider.value;
            arraySizeValue.textContent = size;
            generateNewArray();
        }

        // Update speed display and value
        function updateSpeed() {
            const speed = speedSlider.value;
            speedValue.textContent = speed;
            // Convert speed to delay (faster = lower delay)
            animationSpeed = 110 - (speed * 10);
        }

        // Generate a new random array
        function generateNewArray() {
            if (isSorting) return;
            
            const size = parseInt(arraySizeSlider.value);
            array = [];
            
            for (let i = 0; i < size; i++) {
                array.push(Math.floor(Math.random() * 95) + 5); // Values between 5 and 100
            }
            
            renderArray();
            status.textContent = "> New array generated";
        }

        // Render the array as bars
        function renderArray(highlightIndices = [], highlightClass = "") {
            visualization.innerHTML = '';
            const maxHeight = visualization.clientHeight - 40;
            const barWidth = Math.max(2, (visualization.clientWidth - 20) / array.length - 2);
            
            for (let i = 0; i < array.length; i++) {
                const bar = document.createElement('div');
                bar.className = 'bar';
                bar.style.height = `${(array[i] / 100) * maxHeight}px`;
                bar.style.width = `${barWidth}px`;
                
                if (highlightIndices.includes(i)) {
                    bar.classList.add(highlightClass);
                }
                
                // Add value label for smaller arrays
                if (array.length <= 30) {
                    const label = document.createElement('div');
                    label.style.position = 'absolute';
                    label.style.bottom = '-20px';
                    label.style.width = '100%';
                    label.style.textAlign = 'center';
                    label.style.fontSize = '10px';
                    label.style.color = '#00ff00';
                    label.textContent = array[i];
                    bar.appendChild(label);
                }
                
                visualization.appendChild(bar);
            }
        }

        // Start the sorting process
        function startSorting() {
            if (isSorting) return;
            
            isSorting = true;
            startSortingBtn.disabled = true;
            generateArrayBtn.disabled = true;
            algorithmSelect.disabled = true;
            
            const algorithm = algorithmSelect.value;
            status.textContent = `> Executing ${algorithmDetails[algorithm].name}...`;
            
            // Generate animations based on selected algorithm
            animations = [];
            const arrayCopy = [...array];
            
            switch (algorithm) {
                case 'bubble':
                    bubbleSort(arrayCopy);
                    break;
                case 'selection':
                    selectionSort(arrayCopy);
                    break;
                case 'insertion':
                    insertionSort(arrayCopy);
                    break;
                case 'merge':
                    mergeSort(arrayCopy, 0, arrayCopy.length - 1);
                    break;
                case 'quick':
                    quickSort(arrayCopy, 0, arrayCopy.length - 1);
                    break;
            }
            
            // Play animations
            playAnimations();
        }

        // Bubble Sort algorithm with animation recording
        function bubbleSort(arr) {
            const n = arr.length;
            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    // Compare animation
                    animations.push({ type: 'compare', indices: [j, j+1] });
                    
                    if (arr[j] > arr[j+1]) {
                        // Swap animation
                        animations.push({ type: 'swap', indices: [j, j+1] });
                        [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
                    }
                }
                // Mark as sorted
                animations.push({ type: 'sorted', indices: [n - i - 1] });
            }
            animations.push({ type: 'sorted', indices: [0] });
        }

        // Selection Sort algorithm with animation recording
        function selectionSort(arr) {
            const n = arr.length;
            for (let i = 0; i < n - 1; i++) {
                let minIdx = i;
                animations.push({ type: 'compare', indices: [minIdx] });
                
                for (let j = i + 1; j < n; j++) {
                    animations.push({ type: 'compare', indices: [j] });
                    
                    if (arr[j] < arr[minIdx]) {
                        minIdx = j;
                        animations.push({ type: 'compare', indices: [minIdx] });
                    }
                }
                
                if (minIdx !== i) {
                    animations.push({ type: 'swap', indices: [i, minIdx] });
                    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
                }
                
                animations.push({ type: 'sorted', indices: [i] });
            }
            animations.push({ type: 'sorted', indices: [n - 1] });
        }

        // Insertion Sort algorithm with animation recording
        function insertionSort(arr) {
            const n = arr.length;
            for (let i = 1; i < n; i++) {
                let key = arr[i];
                let j = i - 1;
                
                animations.push({ type: 'compare', indices: [i] });
                
                while (j >= 0 && arr[j] > key) {
                    animations.push({ type: 'compare', indices: [j, j+1] });
                    animations.push({ type: 'swap', indices: [j, j+1] });
                    arr[j + 1] = arr[j];
                    j--;
                }
                arr[j + 1] = key;
            }
            
            // Mark all as sorted at the end
            for (let i = 0; i < n; i++) {
                animations.push({ type: 'sorted', indices: [i] });
            }
        }

        // Merge Sort algorithm with animation recording
        function mergeSort(arr, left, right) {
            if (left >= right) return;
            
            const mid = Math.floor((left + right) / 2);
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }

        function merge(arr, left, mid, right) {
            const leftArr = arr.slice(left, mid + 1);
            const rightArr = arr.slice(mid + 1, right + 1);
            
            let i = 0, j = 0, k = left;
            
            while (i < leftArr.length && j < rightArr.length) {
                animations.push({ type: 'compare', indices: [left + i, mid + 1 + j] });
                
                if (leftArr[i] <= rightArr[j]) {
                    arr[k] = leftArr[i];
                    animations.push({ type: 'swap', indices: [k], value: leftArr[i] });
                    i++;
                } else {
                    arr[k] = rightArr[j];
                    animations.push({ type: 'swap', indices: [k], value: rightArr[j] });
                    j++;
                }
                k++;
            }
            
            while (i < leftArr.length) {
                arr[k] = leftArr[i];
                animations.push({ type: 'swap', indices: [k], value: leftArr[i] });
                i++;
                k++;
            }
            
            while (j < rightArr.length) {
                arr[k] = rightArr[j];
                animations.push({ type: 'swap', indices: [k], value: rightArr[j] });
                j++;
                k++;
            }
            
            // Mark merged section as sorted
            for (let idx = left; idx <= right; idx++) {
                animations.push({ type: 'sorted', indices: [idx] });
            }
        }

        // Quick Sort algorithm with animation recording
        function quickSort(arr, low, high) {
            if (low < high) {
                const pi = partition(arr, low, high);
                quickSort(arr, low, pi - 1);
                quickSort(arr, pi + 1, high);
            }
        }

        function partition(arr, low, high) {
            const pivot = arr[high];
            animations.push({ type: 'pivot', indices: [high] });
            
            let i = low - 1;
            
            for (let j = low; j < high; j++) {
                animations.push({ type: 'compare', indices: [j, high] });
                
                if (arr[j] < pivot) {
                    i++;
                    if (i !== j) {
                        animations.push({ type: 'swap', indices: [i, j] });
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                    }
                }
            }
            
            if (i + 1 !== high) {
                animations.push({ type: 'swap', indices: [i + 1, high] });
                [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
            }
            
            return i + 1;
        }

        // Play the recorded animations
        function playAnimations() {
            let i = 0;
            
            function playNextAnimation() {
                if (i >= animations.length) {
                    // Sorting completed
                    isSorting = false;
                    startSortingBtn.disabled = false;
                    generateArrayBtn.disabled = false;
                    algorithmSelect.disabled = false;
                    status.textContent = "> Sorting completed!";
                    return;
                }
                
                const animation = animations[i];
                
                switch (animation.type) {
                    case 'compare':
                        renderArray(animation.indices, 'comparing');
                        break;
                    case 'swap':
                        if (animation.value !== undefined) {
                            // For merge sort value assignments
                            array[animation.indices[0]] = animation.value;
                        } else {
                            // For regular swaps
                            [array[animation.indices[0]], array[animation.indices[1]]] = 
                            [array[animation.indices[1]], array[animation.indices[0]]];
                        }
                        renderArray(animation.indices, 'swapping');
                        break;
                    case 'sorted':
                        renderArray(animation.indices, 'sorted');
                        break;
                    case 'pivot':
                        renderArray(animation.indices, 'pivot');
                        break;
                }
                
                i++;
                setTimeout(playNextAnimation, animationSpeed);
            }
            
            playNextAnimation();
        }

        // Initialize the application
        init();
    </script>
</body>
</html>
